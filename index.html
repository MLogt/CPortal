<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>HDPro Ordering Portal</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/@emailjs/browser@4/dist/email.min.js"></script>
  <style>
    :root {
      --primary: #111827;
      --bg-body: #f5f5f7;
      --bg-card: #ffffff;
      --border: #e5e7eb;
      --text-main: #222;
      --text-muted: #6b7280;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 16px;
      background: var(--bg-body);
      color: var(--text-main);
    }

    h1, h2, h3 { margin-top: 0; }

    .container {
      max-width: 1100px;
      margin: 0 auto;
      background: var(--bg-card);
      padding: 24px;
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(15, 23, 42, 0.08);
    }

    /* --- Status Badges --- */
    .status-badge {
      display: inline-flex;
      align-items: center;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 500;
      text-transform: capitalize;
    }
    .status-reserved { background: #fef3c7; color: #92400e; }
    .status-paid { background: #dcfce7; color: #166534; }
    .status-shipped { background: #dbeafe; color: #1d4ed8; }
    .status-ready\ for\ pickup { background: #e0f2fe; color: #0369a1; }
    .status-cancelled { background: #fee2e2; color: #b91c1c; }
    .status-invoice-sent { background: #dbeafe; color: #1d4ed8; }
    .status-waiting-po { background: #fef3c7; color: #92400e; }
    .status-default { background: #f3f4f6; color: #374151; }

    /* --- Stock Timeline Card --- */
    .stock-card {
      padding: 16px;
      border-radius: 10px;
      background: #eff6ff;
      border: 1px solid #bfdbfe;
      margin-bottom: 16px;
    }
    .stock-val { font-weight: 700; font-size: 20px; color: #1e3a8a; }
    .stock-monthly { margin-top: 12px; display: flex; flex-wrap: wrap; gap: 8px; }
    .month-chip {
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
    }

    /* Stock Chart */
    .stock-chart-container {
      margin-top: 16px;
      padding: 16px;
      background: #f9fafb;
      border-radius: 8px;
      border: 1px solid #e5e7eb;
    }
    .stock-chart-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 12px;
      color: #374151;
    }
    .stock-chart-wrapper {
      position: relative;
    }
    .stock-chart-bars-area {
      position: relative;
      height: 160px;
      display: flex;
      gap: 8px;
    }
    .stock-chart-zero-line {
      position: absolute;
      left: 0;
      right: 0;
      border-top: 2px dashed #ef4444;
      z-index: 10;
      pointer-events: none;
    }
    .stock-chart-labels {
      display: flex;
      gap: 8px;
      margin-top: 8px;
    }
    .chart-month {
      flex: 1;
      position: relative;
      display: flex;
      justify-content: center;
      gap: 2px;
    }
    .chart-bar {
      width: 16px;
      min-height: 2px;
      border-radius: 2px 2px 0 0;
      position: absolute;
      transition: height 0.3s ease;
    }
    .chart-bar-requested {
      background: linear-gradient(180deg, #3b82f6 0%, #1d4ed8 100%);
      left: calc(50% - 18px);
    }
    .chart-bar-requested.negative {
      background: linear-gradient(0deg, #ef4444 0%, #b91c1c 100%);
      border-radius: 0 0 2px 2px;
    }
    .chart-bar-actual {
      background: linear-gradient(180deg, #22c55e 0%, #16a34a 100%);
      left: calc(50% + 2px);
    }
    .chart-label {
      flex: 1;
      font-size: 10px;
      color: #6b7280;
      text-align: center;
      white-space: nowrap;
    }
    .chart-value {
      font-size: 9px;
      color: #374151;
      font-weight: 500;
      position: absolute;
      top: -14px;
      left: 50%;
      transform: translateX(-50%);
      white-space: nowrap;
    }
    .chart-value.negative {
      color: #dc2626;
      top: auto;
      bottom: -14px;
    }
    .chart-legend {
      display: flex;
      gap: 16px;
      margin-top: 12px;
      justify-content: center;
      font-size: 12px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 2px;
    }
    .legend-requested { background: #3b82f6; }
    .legend-negative { background: #ef4444; }
    .legend-actual { background: #22c55e; }

    /* --- Order Row Colors --- */
    .order-shipped { background: #f3f4f6; color: #9ca3af; }
    .order-shipped td { color: #9ca3af; }
    .order-now { background: #dcfce7; }
    .order-month-feb { background: #dbeafe; }
    .order-month-mar { background: #fef3c7; }
    .order-month-apr { background: #fce7f3; }
    .order-month-may { background: #e0e7ff; }
    .order-month-jun { background: #ccfbf1; }
    .order-month-jul { background: #fee2e2; }
    .order-month-aug { background: #fef9c3; }
    .order-month-sep { background: #f3e8ff; }
    .order-month-oct { background: #cffafe; }
    .order-month-nov { background: #d1fae5; }
    .order-month-dec { background: #ffe4e6; }
    .order-month-jan { background: #e0f2fe; }

    /* Month chip colors matching order rows */
    .chip-now { background: #166534; color: white; }
    .chip-feb { background: #1d4ed8; color: white; }
    .chip-mar { background: #a16207; color: white; }
    .chip-apr { background: #be185d; color: white; }
    .chip-may { background: #4338ca; color: white; }
    .chip-jun { background: #0d9488; color: white; }
    .chip-jul { background: #dc2626; color: white; }
    .chip-aug { background: #ca8a04; color: white; }
    .chip-sep { background: #7c3aed; color: white; }
    .chip-oct { background: #0891b2; color: white; }
    .chip-nov { background: #059669; color: white; }
    .chip-dec { background: #e11d48; color: white; }
    .chip-jan { background: #0284c7; color: white; }
    .chip-negative { background: #dc2626; color: white; font-weight: 700; }

    /* Order delay warning */
    .order-delay {
      font-size: 11px;
      color: #dc2626;
      font-weight: 600;
    }
    .order-delayed-row {
      border-left: 4px solid #dc2626;
    }
    .fulfillment-info {
      font-size: 11px;
      color: #6b7280;
      margin-top: 2px;
    }
    .fulfillment-warning {
      color: #dc2626;
      font-weight: 500;
    }

    /* --- Tables --- */
    .table-wrapper { width: 100%; overflow-x: auto; border-radius: 6px; border: 1px solid var(--border); }
    table { border-collapse: collapse; width: 100%; min-width: 720px; font-size: 14px; }
    th, td { padding: 10px 12px; text-align: left; border-bottom: 1px solid var(--border); }
    th { background: #f9fafb; font-weight: 600; white-space: nowrap; position: sticky; top: 0; }
    .numeric { text-align: right; font-variant-numeric: tabular-nums; }
    .meta { font-size: 13px; color: var(--text-muted); margin-bottom: 16px; }
    .meta-error { margin-top: 4px; font-size: 12px; color: #b91c1c; }

    /* --- Form --- */
    form { margin-top: 16px; padding: 20px; border-radius: 8px; border: 1px solid var(--border); background: #f9fafb; }
    label { display: block; font-size: 14px; margin-bottom: 4px; font-weight: 600; color: #374151; }
    .field { margin-bottom: 16px; }
    input, select, textarea { width: 100%; padding: 8px 10px; border-radius: 6px; border: 1px solid #d1d5db; font-size: 14px; box-sizing: border-box; }
    .input-error { border-color: #b91c1c !important; background-color: #fef2f2; }

    button[type="submit"], .btn-primary {
      background: var(--primary); color: #fff; border: none; padding: 10px 20px; border-radius: 999px;
      font-size: 14px; font-weight: 600; cursor: pointer; transition: opacity 0.2s; width: 100%;
    }
    button[type="submit"]:disabled, .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }

    .btn-secondary {
      background: #fff; color: var(--primary); border: 1px solid var(--border); padding: 10px 20px; border-radius: 999px;
      font-size: 14px; font-weight: 600; cursor: pointer; transition: opacity 0.2s; width: 100%;
    }

    .two-columns { display: grid; grid-template-columns: 1fr; gap: 24px; margin-top: 24px; }
    @media (min-width: 768px) { .two-columns { grid-template-columns: 3fr 2fr; } }

    .card { border-radius: 8px; border: 1px solid var(--border); padding: 16px; background: #f9fafb; font-size: 14px; }
    .message { margin-top: 12px; font-size: 14px; padding: 10px; border-radius: 6px; display: none; }
    .message.error { background: #fee2e2; color: #b91c1c; display: block; }
    .message.success { background: #dcfce7; color: #166534; display: block; }

    /* --- Availability Highlight Box --- */
    .availability-box {
      background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);
      border: 2px solid #10b981;
      border-radius: 10px;
      padding: 16px;
      margin-bottom: 16px;
      display: none;
    }
    .availability-box.show { display: block; }
    .availability-box.error {
      background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
      border-color: #ef4444;
    }
    .availability-date {
      font-size: 18px;
      font-weight: 700;
      color: #047857;
    }
    .availability-box.error .availability-date { color: #b91c1c; }
    .availability-info {
      font-size: 13px;
      color: #065f46;
      margin-top: 4px;
    }
    .availability-box.error .availability-info { color: #991b1b; }

    /* --- Confirmation Modal --- */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .modal-overlay.show { display: flex; }
    .modal {
      background: #fff;
      border-radius: 12px;
      padding: 24px;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
    }
    .modal h3 { margin-bottom: 16px; }
    .modal-content { margin-bottom: 20px; font-size: 15px; line-height: 1.6; }
    .modal-actions { display: flex; gap: 12px; }
    .modal-actions button { flex: 1; }

    .loading { opacity: 0.5; pointer-events: none; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>HDPro Ordering Portal</h1>
      <p class="meta">Enter quantity to see earliest available delivery date. Stock is automatically calculated.</p>
    </header>

    <div class="two-columns">
      <div>
        <div class="stock-card">
          <div id="stock-display" class="stock-val">Loading...</div>
          <div id="stock-meta" class="meta small" style="margin-bottom:0; margin-top:4px;">Checking stock levels...</div>
        </div>

        <div class="stock-chart-container">
          <div class="stock-chart-title">Voorraad per maand</div>
          <div id="stock-chart" class="stock-chart-wrapper"></div>
          <div class="chart-legend">
            <div class="legend-item"><div class="legend-color legend-requested"></div> Gevraagd schema</div>
            <div class="legend-item"><div class="legend-color legend-negative"></div> Tekort</div>
            <div class="legend-item"><div class="legend-color legend-actual"></div> Met vertragingen</div>
          </div>
        </div>

        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom: 8px;">
            <h2>Recent Orders</h2>
            <button id="refresh-btn" style="background:none; border:none; color:#2563eb; cursor:pointer; font-size:13px; text-decoration:underline;">Refresh Dashboard</button>
        </div>

        <div id="orders-loading" class="meta">Loading orders...</div>
        <div class="table-wrapper">
          <table id="orders-table" style="display:none;">
            <thead>
              <tr>
                <th>Date</th>
                <th>Ordered by</th>
                <th>Customer</th>
                <th class="numeric">Kg</th>
                <th>Status</th>
                <th>Planned</th>
                <th>Fulfillment</th>
                <th>Comment</th>
              </tr>
            </thead>
            <tbody id="orders-tbody"></tbody>
          </table>
        </div>
      </div>

      <div>
        <h2>New order</h2>
        <form id="order-form">
          <div class="field">
            <label for="ordered_by_select">Ordered by</label>
            <select id="ordered_by_select" name="ordered_by_select" required>
              <option value="">Select a name...</option>
              <option value="Andrea">Andrea</option>
              <option value="Hugo">Hugo</option>
              <option value="Bob">Bob</option>
              <option value="Fabien">Fabien</option>
              <option value="Maarten S.">Maarten S.</option>
              <option value="Lucas">Lucas</option>
              <option value="Other">Other</option>
            </select>
          </div>

          <div class="field" id="ordered_by_other_field" style="display:none;">
            <label for="ordered_by_other">Other name</label>
            <input id="ordered_by_other" name="ordered_by_other" type="text" />
          </div>

          <div class="field">
            <label for="customer_name">Customer name</label>
            <input id="customer_name" name="customer_name" type="text" placeholder="e.g. Klant BV" required />
          </div>

          <!-- Quantity BEFORE date -->
          <div class="field">
            <label for="quantity_kg">Quantity (kg)</label>
            <input id="quantity_kg" name="quantity_kg" type="number" min="20" step="20" placeholder="e.g. 500" required />
            <div id="quantity-hint" class="meta small" style="margin-top:4px;">Enter quantity to check availability</div>
            <div id="quantity-error" class="meta-error" style="display:none;"></div>
          </div>

          <!-- Availability highlight box -->
          <div id="availability-box" class="availability-box">
            <div id="availability-date" class="availability-date"></div>
            <div id="availability-info" class="availability-info"></div>
          </div>

          <!-- Date selection (after quantity) -->
          <div class="field" id="date-field" style="display:none;">
            <label for="planned_shipping_date">Delivery date</label>
            <input id="planned_shipping_date" name="planned_shipping_date" type="date" required />
            <div id="planned-hint" class="meta small" style="margin-top:4px;"></div>
            <div id="planned-error" class="meta-error" style="display:none;"></div>
          </div>

          <!-- Comment field -->
          <div class="field" id="comment-field" style="display:none;">
            <label for="order_comment">Comment (optional)</label>
            <textarea id="order_comment" name="order_comment" rows="2" placeholder="Any notes about this order..."></textarea>
          </div>

          <div class="field" id="price-field" style="display:none; background: #eff6ff; padding: 10px; border-radius: 6px; font-size: 13px; color: #1e3a8a; border: 1px solid #bfdbfe;">
             <div id="quantity-summary"></div>
             <div id="price-preview" style="margin-top:8px;">
               <div><strong>Customer price:</strong> <span id="customer-price"></span></div>
               <div style="margin-top:4px;"><strong>CEAD price (PO):</strong> <span id="cead-price"></span></div>
             </div>
          </div>

          <div class="field" id="confirm-field" style="display:none; font-size: 13px;">
            <label style="font-weight: normal; display: flex; align-items: flex-start; gap: 8px;">
              <input type="checkbox" id="confirm-checkbox" style="width: auto; margin-top: 3px;">
              <span>I confirm this binding purchase commitment.</span>
            </label>
          </div>

          <button type="submit" id="submit-btn" disabled>Place order</button>
          <div id="form-message" class="message"></div>
        </form>
      </div>
    </div>
  </div>

  <!-- Confirmation Modal -->
  <div id="confirm-modal" class="modal-overlay">
    <div class="modal">
      <h3>Confirm Order</h3>
      <div id="modal-content" class="modal-content"></div>
      <div class="modal-actions">
        <button type="button" class="btn-secondary" id="modal-cancel">Cancel</button>
        <button type="button" class="btn-primary" id="modal-confirm">Confirm Order</button>
      </div>
    </div>
  </div>

  <script>
    "use strict";

    // ============================================
    // Supabase Configuration
    // ============================================
    const SUPABASE_URL = 'https://vclhlfkekfixctkixsnt.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZjbGhsZmtla2ZpeGN0a2l4c250Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzAyMzM1NTMsImV4cCI6MjA4NTgwOTU1M30.K39um4NOiK1SwaXODmoJY5Q3nOSgfOVw8sZFgECqPBI';

    const db = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // ============================================
    // Notification Configuration
    // ============================================
    const NOTIFY_CONFIG = {
        // Ntfy.sh - simple push notifications (recommended)
        ntfyTopic: 'hdpro6-orders-abczzz-666',
        ntfyEnabled: true,

        // EmailJS - email notifications (optional, requires setup)
        emailjs: {
            publicKey: 'YOUR_PUBLIC_KEY',
            serviceId: 'YOUR_SERVICE_ID',
            templateId: 'YOUR_TEMPLATE_ID',
            notifyEmail: 'orders@example.com'
        }
    };

    // Initialize EmailJS if configured
    if (NOTIFY_CONFIG.emailjs.publicKey !== 'YOUR_PUBLIC_KEY') {
        emailjs.init(NOTIFY_CONFIG.emailjs.publicKey);
    }

    // ============================================
    // App Configuration
    // ============================================
    const CONFIG = {
        customerId: 1,
        bagWeight: 20,
        bagsPerPallet: 24,
        leadTimeDays: 5
    };

    const PRICING = [
        { limit: 400, cust: 9.90 },
        { limit: 1200, cust: 9.50 },
        { limit: 5200, cust: 8.80 },
        { limit: Infinity, cust: 8.30 }
    ];

    const MONTH_NAMES = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
    const MONTH_LABELS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

    // App State
    let stockTimeline = [];
    let existingOrders = [];
    let calculatedAvailability = null;
    let debounceTimer = null;

    // ============================================
    // Utility Functions
    // ============================================
    function getPrice(kg) {
        const tier = PRICING.find(p => kg <= p.limit) || PRICING[PRICING.length - 1];
        const customerPrice = tier.cust;
        const ceadPrice = (customerPrice - 6.66) / 2 + 6.66;
        return {
            customer: customerPrice,
            cead: Math.round(ceadPrice * 100) / 100 // Round to 2 decimals
        };
    }

    function formatDate(dateStr) {
        const d = new Date(dateStr);
        return d.toLocaleDateString("en-GB", { weekday: 'short', day: 'numeric', month: 'short', year: 'numeric' });
    }

    function formatDateShort(dateStr) {
        const d = new Date(dateStr);
        return d.toLocaleDateString("en-GB");
    }

    function formatDateISO(date) {
        // Use local date components to avoid timezone shifts
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    }

    // Send push notification via ntfy.sh
    async function sendNtfyNotification(orderData) {
        if (!NOTIFY_CONFIG.ntfyEnabled || NOTIFY_CONFIG.ntfyTopic === 'hdpro-orders-CHANGE-THIS') {
            console.log('Ntfy not configured - skipping push notification');
            return { success: false, reason: 'not_configured' };
        }

        const customerTotal = (orderData.customer_unit_price * orderData.quantity_kg).toFixed(2);
        const ceadTotal = (orderData.cead_unit_price * orderData.quantity_kg).toFixed(2);

        const message = [
            `ðŸ“¦ New Order #${orderData.id || 'N/A'}`,
            ``,
            `Customer: ${orderData.customer}`,
            `Ordered by: ${orderData.ordered_by}`,
            `Quantity: ${orderData.quantity_kg} kg`,
            `Delivery: ${formatDate(orderData.planned_shipping_date)}`,
            ``,
            `ðŸ’° Customer: â‚¬${customerTotal} (â‚¬${orderData.customer_unit_price.toFixed(2)}/kg)`,
            `ðŸ’¼ CEAD PO: â‚¬${ceadTotal} (â‚¬${orderData.cead_unit_price.toFixed(2)}/kg)`,
            orderData.comment ? `\nðŸ“ ${orderData.comment}` : ''
        ].filter(Boolean).join('\n');

        try {
            const response = await fetch(`https://ntfy.sh/${NOTIFY_CONFIG.ntfyTopic}`, {
                method: 'POST',
                headers: {
                    'Title': `HDPro Order: ${orderData.quantity_kg}kg - ${orderData.customer}`,
                    'Tags': 'package,moneybag'
                },
                body: message
            });

            if (response.ok) {
                console.log('Ntfy notification sent successfully');
                return { success: true };
            } else {
                throw new Error(`HTTP ${response.status}`);
            }
        } catch (error) {
            console.error('Failed to send ntfy notification:', error);
            return { success: false, error };
        }
    }

    // Send order confirmation email (optional)
    async function sendOrderConfirmationEmail(orderData) {
        // Skip if EmailJS not configured
        if (NOTIFY_CONFIG.emailjs.publicKey === 'YOUR_PUBLIC_KEY') {
            console.log('EmailJS not configured - skipping email notification');
            return { success: false, reason: 'not_configured' };
        }

        const templateParams = {
            to_email: NOTIFY_CONFIG.emailjs.notifyEmail,
            order_id: orderData.id || 'N/A',
            customer_name: orderData.customer,
            ordered_by: orderData.ordered_by,
            quantity_kg: orderData.quantity_kg,
            planned_date: formatDate(orderData.planned_shipping_date),
            customer_price: `â‚¬${orderData.customer_unit_price.toFixed(2)}/kg`,
            customer_total: `â‚¬${(orderData.customer_unit_price * orderData.quantity_kg).toFixed(2)}`,
            cead_price: `â‚¬${orderData.cead_unit_price.toFixed(2)}/kg`,
            cead_total: `â‚¬${(orderData.cead_unit_price * orderData.quantity_kg).toFixed(2)}`,
            comment: orderData.comment || '-',
            order_date: new Date().toLocaleDateString("en-GB", {
                weekday: 'short', day: 'numeric', month: 'short', year: 'numeric',
                hour: '2-digit', minute: '2-digit'
            })
        };

        try {
            const response = await emailjs.send(
                NOTIFY_CONFIG.emailjs.serviceId,
                NOTIFY_CONFIG.emailjs.templateId,
                templateParams
            );
            console.log('Order confirmation email sent:', response);
            return { success: true, response };
        } catch (error) {
            console.error('Failed to send order confirmation email:', error);
            return { success: false, error };
        }
    }

    // Send all configured notifications
    async function sendOrderNotifications(orderData) {
        // Send ntfy push notification
        sendNtfyNotification(orderData);

        // Send email notification (if configured)
        sendOrderConfirmationEmail(orderData);
    }

    // ============================================
    // Stock Calculation Functions
    // ============================================
    function getMinimumOrderDate() {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        let date = new Date(today);
        let businessDays = 0;
        while (businessDays < CONFIG.leadTimeDays) {
            date.setDate(date.getDate() + 1);
            if (date.getDay() !== 0 && date.getDay() !== 6) businessDays++;
        }
        return date;
    }

    function getNextIncomingDate() {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        for (const entry of stockTimeline) {
            const entryDate = new Date(entry.date);
            if (entryDate > today) {
                return entry.date;
            }
        }
        return null;
    }

    function calculateAvailableOnDate(targetDateStr) {
        const targetDate = new Date(targetDateStr);
        let available = 0;

        stockTimeline.forEach(entry => {
            if (new Date(entry.date) <= targetDate) {
                available += entry.incoming_kg;
            }
        });

        existingOrders.forEach(order => {
            const status = order.status.toLowerCase();
            if (status !== 'shipped' && status !== 'delivered' && status !== 'cancelled') {
                if (order.planned_shipping_date && new Date(order.planned_shipping_date) <= targetDate) {
                    available -= order.quantity_kg;
                }
            }
        });

        return available;
    }

    function getAvailableForImmediateDelivery() {
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        let currentStock = 0;
        stockTimeline.forEach(entry => {
            if (new Date(entry.date) <= today) {
                currentStock += entry.incoming_kg;
            }
        });

        const nextIncoming = getNextIncomingDate();

        existingOrders.forEach(order => {
            const status = order.status.toLowerCase();
            if (status === 'shipped' || status === 'delivered' || status === 'cancelled') return;

            if (order.planned_shipping_date) {
                const plannedDate = new Date(order.planned_shipping_date);
                if (!nextIncoming || plannedDate < new Date(nextIncoming)) {
                    currentStock -= order.quantity_kg;
                }
            }
        });

        return currentStock;
    }

    function getMonthlyStockForecast() {
        const today = new Date();
        const forecast = [];

        for (let i = 0; i < 12; i++) {
            const month = new Date(today.getFullYear(), today.getMonth() + i + 1, 0);
            const monthStr = formatDateISO(month);
            const available = calculateAvailableOnDate(monthStr);

            forecast.push({
                month: MONTH_NAMES[month.getMonth()],
                label: `${MONTH_LABELS[month.getMonth()]} ${month.getFullYear()}`,
                shortLabel: MONTH_LABELS[month.getMonth()],
                available: available,
                year: month.getFullYear()
            });
        }

        return forecast;
    }

    // Calculate stock with delays (orders shifted to when they can actually be fulfilled)
    function calculateStockWithDelays(monthEndDate) {
        const targetDate = new Date(monthEndDate);
        let available = 0;

        // Add all incoming stock up to target date
        stockTimeline.forEach(entry => {
            if (new Date(entry.date) <= targetDate) {
                available += entry.incoming_kg;
            }
        });

        // Subtract orders based on their ACTUAL fulfillment date (not planned)
        existingOrders.forEach(order => {
            const status = order.status.toLowerCase();
            if (status === 'shipped' || status === 'delivered' || status === 'cancelled') return;

            // Calculate when this order can actually be fulfilled
            const fulfillment = calculateOrderFulfillment(order);
            const actualDate = fulfillment.earliestDate ? new Date(fulfillment.earliestDate) :
                              (order.planned_shipping_date ? new Date(order.planned_shipping_date) : null);

            if (actualDate && actualDate <= targetDate) {
                available -= order.quantity_kg;
            }
        });

        return Math.max(0, available); // Never below 0 with delays
    }

    function getMonthlyStockWithDelays() {
        const today = new Date();
        const forecast = [];

        for (let i = 0; i < 8; i++) {
            const month = new Date(today.getFullYear(), today.getMonth() + i + 1, 0);
            const monthStr = formatDateISO(month);
            const requested = calculateAvailableOnDate(monthStr);
            const withDelays = calculateStockWithDelays(monthStr);

            forecast.push({
                month: MONTH_NAMES[month.getMonth()],
                label: `${MONTH_LABELS[month.getMonth()]} ${month.getFullYear()}`,
                shortLabel: MONTH_LABELS[month.getMonth()],
                requested: requested,
                withDelays: withDelays,
                year: month.getFullYear()
            });
        }

        return forecast;
    }

    function renderStockChart(forecast) {
        const chart = document.getElementById('stock-chart');

        // Find max and min values for scaling
        let maxVal = 0;
        let minVal = 0;
        forecast.forEach(m => {
            maxVal = Math.max(maxVal, m.requested, m.withDelays);
            minVal = Math.min(minVal, m.requested);
        });

        // Add padding (20% extra)
        maxVal = Math.max(maxVal * 1.2, 1000);
        minVal = Math.min(minVal * 1.2, 0);

        const totalRange = maxVal - minVal;
        const chartHeight = 160;

        // Calculate where zero line should be (from bottom of bars area)
        const zeroFromBottom = totalRange > 0 ? (Math.abs(minVal) / totalRange) * chartHeight : 0;

        chart.innerHTML = '';

        // Create bars area container
        const barsArea = document.createElement('div');
        barsArea.className = 'stock-chart-bars-area';

        // Add zero line inside the bars area
        const zeroLine = document.createElement('div');
        zeroLine.className = 'stock-chart-zero-line';
        zeroLine.style.bottom = `${zeroFromBottom}px`;
        barsArea.appendChild(zeroLine);

        // Create labels container
        const labelsArea = document.createElement('div');
        labelsArea.className = 'stock-chart-labels';

        forecast.forEach(m => {
            // Month column for bars
            const monthDiv = document.createElement('div');
            monthDiv.className = 'chart-month';

            // Requested bar (can be negative)
            const requestedBar = document.createElement('div');
            requestedBar.className = 'chart-bar chart-bar-requested';

            if (m.requested < 0) {
                requestedBar.classList.add('negative');
                const height = totalRange > 0 ? (Math.abs(m.requested) / totalRange) * chartHeight : 0;
                requestedBar.style.height = `${Math.max(height, 4)}px`;
                // Negative bar: starts at zero and goes DOWN
                requestedBar.style.bottom = `${zeroFromBottom - height}px`;
                requestedBar.innerHTML = `<span class="chart-value negative">${m.requested}</span>`;
            } else {
                const height = totalRange > 0 ? (m.requested / totalRange) * chartHeight : 0;
                requestedBar.style.height = `${Math.max(height, 4)}px`;
                // Positive bar: starts at zero and goes UP
                requestedBar.style.bottom = `${zeroFromBottom}px`;
                requestedBar.innerHTML = `<span class="chart-value">${m.requested}</span>`;
            }
            monthDiv.appendChild(requestedBar);

            // Actual bar (with delays, never negative)
            const actualBar = document.createElement('div');
            actualBar.className = 'chart-bar chart-bar-actual';
            const actualHeight = totalRange > 0 ? (m.withDelays / totalRange) * chartHeight : 0;
            actualBar.style.height = `${Math.max(actualHeight, 4)}px`;
            actualBar.style.bottom = `${zeroFromBottom}px`;
            actualBar.innerHTML = `<span class="chart-value">${m.withDelays}</span>`;
            monthDiv.appendChild(actualBar);

            barsArea.appendChild(monthDiv);

            // Label for this month
            const label = document.createElement('div');
            label.className = 'chart-label';
            label.textContent = m.shortLabel;
            labelsArea.appendChild(label);
        });

        chart.appendChild(barsArea);
        chart.appendChild(labelsArea);
    }

    // ============================================
    // Stock Period Calculations
    // ============================================

    // Get cumulative stock available at a specific date
    function getStockAtDate(targetDate) {
        const target = new Date(targetDate);
        let stock = 0;

        stockTimeline.forEach(entry => {
            if (new Date(entry.date) <= target) {
                stock += entry.incoming_kg;
            }
        });

        return stock;
    }

    // Get all pending orders sorted by planned date
    function getPendingOrdersSorted() {
        return existingOrders
            .filter(order => {
                const status = order.status.toLowerCase();
                return status !== 'shipped' && status !== 'delivered' && status !== 'cancelled';
            })
            .filter(order => order.planned_shipping_date)
            .sort((a, b) => new Date(a.planned_shipping_date) - new Date(b.planned_shipping_date));
    }

    // Calculate available stock at a date, considering orders planned before that date
    // excludeOrderId: optionally exclude a specific order from the calculation
    function getAvailableStockAtDate(targetDate, excludeOrderId = null) {
        const target = new Date(targetDate);

        // Get total incoming stock up to this date
        let available = getStockAtDate(targetDate);

        // Subtract all pending orders with planned date <= target date
        existingOrders.forEach(order => {
            const status = order.status.toLowerCase();
            if (status === 'shipped' || status === 'delivered' || status === 'cancelled') return;
            if (excludeOrderId && order.id === excludeOrderId) return;

            if (order.planned_shipping_date) {
                const plannedDate = new Date(order.planned_shipping_date);
                if (plannedDate <= target) {
                    available -= order.quantity_kg;
                }
            }
        });

        return available;
    }

    function calculateOrderFulfillment(order) {
        const status = order.status.toLowerCase();

        if (status === 'shipped' || status === 'delivered') {
            return { canFulfillOnPlanned: true, earliestDate: order.planned_shipping_date, delayDays: 0 };
        }

        if (!order.planned_shipping_date) {
            return { canFulfillOnPlanned: false, earliestDate: null, delayDays: null };
        }

        const plannedDate = new Date(order.planned_shipping_date);
        const orderQty = order.quantity_kg;

        // Get all pending orders sorted by planned date (first-come-first-served)
        const sortedOrders = getPendingOrdersSorted();

        // Calculate how much stock is consumed by orders planned BEFORE this one
        let stockConsumedBefore = 0;
        for (const otherOrder of sortedOrders) {
            if (otherOrder.id === order.id) break; // Stop when we reach this order

            const otherPlanned = new Date(otherOrder.planned_shipping_date);
            if (otherPlanned <= plannedDate) {
                stockConsumedBefore += otherOrder.quantity_kg;
            }
        }

        // Check if order can be fulfilled on planned date
        const stockAtPlanned = getStockAtDate(order.planned_shipping_date);
        const availableForThisOrder = stockAtPlanned - stockConsumedBefore;

        if (availableForThisOrder >= orderQty) {
            return { canFulfillOnPlanned: true, earliestDate: order.planned_shipping_date, delayDays: 0 };
        }

        // Not enough stock on planned date - find earliest date with enough stock
        // We need to find when: stockAtDate - ordersBeforeThisDate >= orderQty

        // Build a timeline of dates when stock changes (incoming deliveries)
        const stockDates = stockTimeline
            .map(e => new Date(e.date))
            .filter(d => d > plannedDate)
            .sort((a, b) => a - b);

        // Check each stock delivery date
        for (const checkDate of stockDates) {
            const stockAtCheck = getStockAtDate(checkDate);

            // Orders planned before this order AND before checkDate consume stock
            let consumed = 0;
            for (const otherOrder of sortedOrders) {
                if (otherOrder.id === order.id) break;

                const otherPlanned = new Date(otherOrder.planned_shipping_date);
                if (otherPlanned <= checkDate) {
                    consumed += otherOrder.quantity_kg;
                }
            }

            const availableAtCheck = stockAtCheck - consumed;

            if (availableAtCheck >= orderQty) {
                // Find first weekday on or after this date
                let earliestDate = new Date(checkDate);
                while (earliestDate.getDay() === 0 || earliestDate.getDay() === 6) {
                    earliestDate.setDate(earliestDate.getDate() + 1);
                }

                const delayDays = Math.ceil((earliestDate - plannedDate) / (1000 * 60 * 60 * 24));

                return {
                    canFulfillOnPlanned: false,
                    earliestDate: formatDateISO(earliestDate),
                    delayDays: Math.max(0, delayDays)
                };
            }
        }

        // No stock delivery date found - check if there's ever enough stock
        const totalStock = stockTimeline.reduce((sum, e) => sum + e.incoming_kg, 0);
        const totalOrders = sortedOrders.reduce((sum, o) => sum + o.quantity_kg, 0);

        if (totalStock >= totalOrders) {
            // There will eventually be enough, use last stock date
            const lastStockDate = stockTimeline
                .map(e => new Date(e.date))
                .sort((a, b) => b - a)[0];

            let earliestDate = new Date(lastStockDate);
            while (earliestDate.getDay() === 0 || earliestDate.getDay() === 6) {
                earliestDate.setDate(earliestDate.getDate() + 1);
            }

            const delayDays = Math.ceil((earliestDate - plannedDate) / (1000 * 60 * 60 * 24));

            return {
                canFulfillOnPlanned: false,
                earliestDate: formatDateISO(earliestDate),
                delayDays: Math.max(0, delayDays)
            };
        }

        return { canFulfillOnPlanned: false, earliestDate: null, delayDays: null };
    }

    // Legacy function for compatibility - builds period summary
    function buildStockPeriods() {
        const periods = [];
        const sortedTimeline = [...stockTimeline].sort((a, b) => new Date(a.date) - new Date(b.date));

        for (let i = 0; i < sortedTimeline.length; i++) {
            const entry = sortedTimeline[i];
            const nextEntry = sortedTimeline[i + 1];

            const periodStart = entry.date;
            const periodEnd = nextEntry ? nextEntry.date : null;

            let stockPool = 0;
            for (let j = 0; j <= i; j++) {
                stockPool += sortedTimeline[j].incoming_kg;
            }

            // Now calculate committed orders correctly - only orders within this period
            let committedOrders = 0;
            existingOrders.forEach(order => {
                const status = order.status.toLowerCase();
                if (status === 'shipped' || status === 'delivered' || status === 'cancelled') return;

                if (order.planned_shipping_date) {
                    const plannedDate = new Date(order.planned_shipping_date);
                    const periodEndDate = periodEnd ? new Date(periodEnd) : null;

                    // Count orders up to this period's end
                    if (!periodEndDate || plannedDate < periodEndDate) {
                        committedOrders += order.quantity_kg;
                    }
                }
            });

            periods.push({
                startDate: periodStart,
                endDate: periodEnd,
                stockPool: stockPool,
                committedOrders: committedOrders,
                freeStock: stockPool - committedOrders
            });
        }

        return periods;
    }

    function findFirstAvailableDate(requestedKg) {
        const minDate = getMinimumOrderDate();
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        // First, calculate ACTUAL fulfillment dates for all existing orders
        // This tells us when each order will really be fulfilled (accounting for delays)
        const orderFulfillments = existingOrders
            .filter(order => {
                const status = order.status.toLowerCase();
                return status !== 'shipped' && status !== 'delivered' && status !== 'cancelled';
            })
            .map(order => ({
                order: order,
                fulfillment: calculateOrderFulfillment(order)
            }));

        // Helper: calculate stock consumed by orders actually fulfilled by a given date
        // excludeOrderId: optionally exclude one order from the count
        function getConsumedByDate(targetDate, excludeOrderId = null) {
            let consumed = 0;
            orderFulfillments.forEach(({ order, fulfillment }) => {
                if (excludeOrderId && order.id === excludeOrderId) return;
                if (fulfillment.earliestDate) {
                    const actualDate = new Date(fulfillment.earliestDate);
                    if (actualDate <= targetDate) {
                        consumed += order.quantity_kg;
                    }
                }
            });
            return consumed;
        }

        // Helper: check if placing new order at candidateDate would delay any existing order
        function wouldDelayExistingOrders(candidateDate, newOrderQty) {
            for (const { order, fulfillment } of orderFulfillments) {
                if (!fulfillment.earliestDate) continue;

                const existingFulfillmentDate = new Date(fulfillment.earliestDate);

                // If new order is placed before or on existing order's fulfillment date,
                // check if there's still enough stock for the existing order
                if (candidateDate <= existingFulfillmentDate) {
                    const stockAtExisting = getStockAtDate(existingFulfillmentDate);
                    // Exclude current order from consumed count to avoid double-counting
                    const consumedByOthers = getConsumedByDate(existingFulfillmentDate, order.id);
                    const availableForThisOrder = stockAtExisting - consumedByOthers - newOrderQty;

                    if (availableForThisOrder < order.quantity_kg) {
                        return true; // Would delay this order
                    }
                }
            }
            return false;
        }

        // Build list of candidate dates to check
        // Start with minDate, then each stock delivery date
        const candidateDates = [new Date(minDate)];
        stockTimeline.forEach(entry => {
            const d = new Date(entry.date);
            if (d > minDate) {
                candidateDates.push(d);
            }
        });
        candidateDates.sort((a, b) => a - b);

        // Check each candidate date
        for (const candidateDate of candidateDates) {
            const stockAtDate = getStockAtDate(candidateDate);
            const consumedByDate = getConsumedByDate(candidateDate);
            const available = stockAtDate - consumedByDate;

            if (available >= requestedKg) {
                // Check if this would delay any existing orders
                if (!wouldDelayExistingOrders(candidateDate, requestedKg)) {
                    let deliveryDate = new Date(candidateDate);

                    // Find first weekday
                    while (deliveryDate.getDay() === 0 || deliveryDate.getDay() === 6) {
                        deliveryDate.setDate(deliveryDate.getDate() + 1);
                    }

                    return {
                        date: formatDateISO(deliveryDate),
                        available_kg: available,
                        message: null
                    };
                }
            }
        }

        // No date found
        const totalStock = stockTimeline.reduce((sum, e) => sum + e.incoming_kg, 0);
        const totalOrders = existingOrders
            .filter(order => {
                const status = order.status.toLowerCase();
                return status !== 'shipped' && status !== 'delivered' && status !== 'cancelled';
            })
            .reduce((sum, order) => sum + order.quantity_kg, 0);
        const maxAvailable = Math.max(0, totalStock - totalOrders);

        return {
            date: null,
            available_kg: maxAvailable,
            message: `Insufficient stock. Maximum available for new orders: ${maxAvailable}kg`
        };
    }

    function getOrderMonthClass(order) {
        const status = order.status.toLowerCase();

        if (status === 'shipped' || status === 'delivered') {
            return 'order-shipped';
        }

        if (!order.planned_shipping_date) return '';

        const plannedDate = new Date(order.planned_shipping_date);
        const nextIncoming = getNextIncomingDate();

        if (!nextIncoming || plannedDate < new Date(nextIncoming)) {
            return 'order-now';
        }

        const monthName = MONTH_NAMES[plannedDate.getMonth()];
        return `order-month-${monthName}`;
    }

    // ============================================
    // Data Loading (Supabase)
    // ============================================
    async function loadDashboard() {
        const els = {
            stockVal: document.getElementById("stock-display"),
            stockMeta: document.getElementById("stock-meta"),
            loader: document.getElementById("orders-loading"),
            table: document.getElementById("orders-table"),
            tbody: document.getElementById("orders-tbody")
        };

        try {
            // Load stock levels
            const { data: stockData, error: stockError } = await db
                .from('stock_levels')
                .select('*')
                .order('date', { ascending: true });

            if (stockError) throw stockError;

            // Load orders
            const { data: ordersData, error: ordersError } = await db
                .from('orders')
                .select('*')
                .order('timestamp', { ascending: false });

            if (ordersError) throw ordersError;

            // Transform data
            stockTimeline = stockData.map(row => ({
                date: row.date,
                incoming_kg: row.incoming_kg,
                description: row.description || ''
            }));

            existingOrders = ordersData.map(row => ({
                id: row.id,
                timestamp: row.timestamp,
                customer_id: row.customer_id,
                customer: row.customer,
                ordered_by: row.ordered_by,
                quantity_kg: row.quantity_kg,
                status: row.status || 'reserved',
                comment: row.comment || '',
                planned_shipping_date: row.planned_shipping_date
            }));

            // Update display
            const immediateAvailable = getAvailableForImmediateDelivery();
            const nextIncoming = getNextIncomingDate();
            const nextIncomingText = nextIncoming ? ` (volgende levering: ${formatDateShort(nextIncoming)})` : '';

            els.stockVal.textContent = `${immediateAvailable} kg beschikbaar voor directe levering`;
            els.stockMeta.textContent = nextIncomingText;

            // Render stock chart
            const forecastWithDelays = getMonthlyStockWithDelays();
            renderStockChart(forecastWithDelays);

            // Orders table
            els.loader.style.display = "none";
            els.table.style.display = "table";
            els.tbody.innerHTML = "";

            existingOrders.forEach(order => {
                const tr = document.createElement("tr");
                const d = new Date(order.timestamp);

                const rowClass = getOrderMonthClass(order);
                if (rowClass) tr.className = rowClass;

                const fulfillment = calculateOrderFulfillment(order);
                if (fulfillment.delayDays && fulfillment.delayDays > 0) {
                    tr.classList.add('order-delayed-row');
                }

                let fulfillmentHtml = '';
                const status = order.status.toLowerCase();
                if (status === 'shipped' || status === 'delivered') {
                    fulfillmentHtml = '<span style="color:#6b7280">-</span>';
                } else if (fulfillment.canFulfillOnPlanned) {
                    fulfillmentHtml = '<span style="color:#16a34a">âœ“ On time</span>';
                } else if (fulfillment.earliestDate) {
                    const earliestDate = new Date(fulfillment.earliestDate).toLocaleDateString("en-GB");
                    fulfillmentHtml = `
                        <div class="fulfillment-warning">âš  +${fulfillment.delayDays} days</div>
                        <div class="fulfillment-info">Earliest: ${earliestDate}</div>
                    `;
                } else {
                    fulfillmentHtml = '<span class="fulfillment-warning">âš  No stock</span>';
                }

                tr.innerHTML = `
                    <td>${isNaN(d) ? order.timestamp : d.toLocaleDateString("en-GB")}</td>
                    <td>${order.ordered_by}</td>
                    <td>${order.customer}</td>
                    <td class="numeric">${order.quantity_kg}</td>
                    <td><span class="status-badge status-${order.status.toLowerCase().replace(/ /g, '-')}">${order.status}</span></td>
                    <td>${order.planned_shipping_date ? new Date(order.planned_shipping_date).toLocaleDateString("en-GB") : '-'}</td>
                    <td>${fulfillmentHtml}</td>
                    <td>${order.comment || ''}</td>
                `;
                els.tbody.appendChild(tr);
            });

        } catch (err) {
            console.error('Error loading dashboard:', err);
            els.stockVal.textContent = "Error";
            els.stockMeta.textContent = "Could not connect to database: " + err.message;
        }
    }

    // ============================================
    // Form Handling
    // ============================================
    async function checkAvailability(qty) {
        const availBox = document.getElementById("availability-box");
        const availDate = document.getElementById("availability-date");
        const availInfo = document.getElementById("availability-info");
        const dateField = document.getElementById("date-field");
        const dateInput = document.getElementById("planned_shipping_date");
        const plannedHint = document.getElementById("planned-hint");

        availBox.classList.remove("show", "error");
        dateField.style.display = "none";

        if (!qty || qty < 20) {
            calculatedAvailability = null;
            return;
        }

        availBox.classList.add("show");
        availDate.textContent = "Checking availability...";
        availInfo.textContent = "";

        const result = findFirstAvailableDate(qty);
        calculatedAvailability = result;

        if (result.date) {
            availBox.classList.remove("error");
            availDate.textContent = `Earliest delivery: ${formatDate(result.date)}`;
            availInfo.textContent = `${result.available_kg}kg available for new orders`;

            dateField.style.display = "block";
            dateInput.value = result.date;
            dateInput.min = result.date;
            plannedHint.textContent = `You can select ${formatDateShort(result.date)} or any later weekday with stock`;

            validateForm();
        } else {
            availBox.classList.add("error");
            availDate.textContent = "Insufficient stock";
            availInfo.textContent = result.message || `Maximum available: ${result.available_kg}kg`;
            calculatedAvailability = null;
        }
    }

    function validateForm() {
        const els = {
            qty: document.getElementById("quantity_kg"),
            date: document.getElementById("planned_shipping_date"),
            submit: document.getElementById("submit-btn"),
            summary: document.getElementById("quantity-summary"),
            pricePrev: document.getElementById("price-preview"),
            qtyErr: document.getElementById("quantity-error"),
            plannedErr: document.getElementById("planned-error"),
            priceField: document.getElementById("price-field"),
            confirmField: document.getElementById("confirm-field"),
            confirmCheckbox: document.getElementById("confirm-checkbox")
        };

        els.qtyErr.style.display = "none";
        els.plannedErr.style.display = "none";
        els.qty.classList.remove("input-error");
        els.date.classList.remove("input-error");
        els.priceField.style.display = "none";
        els.confirmField.style.display = "none";
        document.getElementById('comment-field').style.display = 'none';
        els.submit.disabled = true;

        const qty = Number(els.qty.value);
        const dateVal = els.date.value;

        if (!qty || !dateVal || !calculatedAvailability) return false;

        if (qty % 20 !== 0) {
            els.qtyErr.textContent = "Must be multiple of 20kg";
            els.qtyErr.style.display = "block";
            els.qty.classList.add("input-error");
            return false;
        }

        const minDate = getMinimumOrderDate();
        const selectedDate = new Date(dateVal);
        if (selectedDate < minDate) {
            els.plannedErr.textContent = `Date must be ${formatDateShort(formatDateISO(minDate))} or later`;
            els.plannedErr.style.display = "block";
            els.date.classList.add("input-error");
            return false;
        }

        if (selectedDate.getDay() === 0 || selectedDate.getDay() === 6) {
            els.plannedErr.textContent = "Date must be a weekday";
            els.plannedErr.style.display = "block";
            els.date.classList.add("input-error");
            return false;
        }

        const prices = getPrice(qty);
        els.summary.textContent = `Order: ${qty}kg for delivery on ${formatDateShort(dateVal)}`;
        document.getElementById('customer-price').textContent = `â‚¬${prices.customer.toFixed(2)}/kg (Total â‚¬${(prices.customer * qty).toFixed(2)})`;
        document.getElementById('cead-price').textContent = `â‚¬${prices.cead.toFixed(2)}/kg (Total â‚¬${(prices.cead * qty).toFixed(2)})`;
        document.getElementById('comment-field').style.display = 'block';
        els.priceField.style.display = "block";
        els.confirmField.style.display = "block";

        els.submit.disabled = !els.confirmCheckbox.checked;

        return els.confirmCheckbox.checked;
    }

    function setupForm() {
        const els = {
            qty: document.getElementById("quantity_kg"),
            date: document.getElementById("planned_shipping_date"),
            submit: document.getElementById("submit-btn"),
            orderedSelect: document.getElementById("ordered_by_select"),
            orderedOther: document.getElementById("ordered_by_other_field"),
            msg: document.getElementById("form-message"),
            form: document.getElementById("order-form"),
            confirmCheckbox: document.getElementById("confirm-checkbox"),
            modal: document.getElementById("confirm-modal"),
            modalContent: document.getElementById("modal-content"),
            modalCancel: document.getElementById("modal-cancel"),
            modalConfirm: document.getElementById("modal-confirm")
        };

        els.qty.addEventListener("input", () => {
            clearTimeout(debounceTimer);
            const qty = Number(els.qty.value);

            const qtyErr = document.getElementById("quantity-error");
            const qtyHint = document.getElementById("quantity-hint");
            if (qty && qty % 20 !== 0) {
                qtyErr.textContent = "Must be multiple of 20kg";
                qtyErr.style.display = "block";
                qtyHint.style.display = "none";
            } else {
                qtyErr.style.display = "none";
                qtyHint.style.display = qty ? "none" : "block";
            }

            debounceTimer = setTimeout(() => {
                if (qty >= 20 && qty % 20 === 0) {
                    checkAvailability(qty);
                } else {
                    document.getElementById("availability-box").classList.remove("show");
                    document.getElementById("date-field").style.display = "none";
                    document.getElementById("comment-field").style.display = "none";
                    document.getElementById("price-field").style.display = "none";
                    document.getElementById("confirm-field").style.display = "none";
                    els.submit.disabled = true;
                    calculatedAvailability = null;
                }
            }, 300);
        });

        els.date.addEventListener("change", () => validateForm());
        els.confirmCheckbox.addEventListener("change", () => validateForm());

        els.orderedSelect.addEventListener("change", () => {
            els.orderedOther.style.display = els.orderedSelect.value === "Other" ? "block" : "none";
        });

        // Store modal prices for use when confirming
        let modalPrices = { customerTotal: 0, ceadTotal: 0, qty: 0, originalCeadPerKg: 0 };

        els.form.addEventListener("submit", (e) => {
            e.preventDefault();

            const qty = Number(els.qty.value);
            const dateVal = els.date.value;
            const prices = getPrice(qty);
            const orderedBy = els.orderedSelect.value === "Other"
                ? document.getElementById("ordered_by_other").value
                : els.orderedSelect.value;
            const customerName = document.getElementById("customer_name").value;
            const comment = document.getElementById("order_comment").value;

            // Store original values
            modalPrices = {
                customerTotal: prices.customer * qty,
                ceadTotal: prices.cead * qty,
                qty: qty,
                originalCeadPerKg: prices.cead
            };

            els.modalContent.innerHTML = `
                <p><strong>Order ${qty}kg</strong> for delivery on <strong>${formatDate(dateVal)}</strong></p>
                <p>Customer: ${customerName}</p>
                <p>Ordered by: ${orderedBy}</p>
                ${comment ? `<p>Comment: ${comment}</p>` : ''}
                <hr style="margin: 12px 0; border: none; border-top: 1px solid #e5e7eb;">
                <div style="margin-bottom: 12px;">
                    <label style="font-size: 14px; font-weight: 600; display: block; margin-bottom: 4px;">Customer total:</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span>â‚¬</span>
                        <input type="number" id="modal-customer-total" value="${(prices.customer * qty).toFixed(2)}"
                               step="0.01" min="0" style="width: 120px; padding: 6px 10px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px;">
                        <span style="color: #6b7280; font-size: 13px;">(â‚¬<span id="modal-customer-per-kg">${prices.customer.toFixed(2)}</span>/kg)</span>
                    </div>
                </div>
                <div>
                    <label style="font-size: 14px; font-weight: 600; display: block; margin-bottom: 4px;">CEAD total (PO):</label>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span><strong>â‚¬<span id="modal-cead-total">${(prices.cead * qty).toFixed(2)}</span></strong></span>
                        <span style="color: #6b7280; font-size: 13px;">(â‚¬<span id="modal-cead-per-kg">${prices.cead.toFixed(2)}</span>/kg)</span>
                    </div>
                    <p style="font-size: 11px; color: #6b7280; margin-top: 4px;">Auto-calculated based on customer price</p>
                </div>
            `;

            // Add event listener for customer total changes
            const customerTotalInput = document.getElementById('modal-customer-total');
            customerTotalInput.addEventListener('input', () => {
                const newCustomerTotal = Number(customerTotalInput.value) || 0;
                const newCustomerPerKg = newCustomerTotal / modalPrices.qty;

                // Calculate new CEAD price using formula
                const calculatedCeadPerKg = (newCustomerPerKg - 6.66) / 2 + 6.66;

                // Use max of original CEAD price or calculated (CEAD doesn't lose money on discounts)
                const finalCeadPerKg = Math.max(modalPrices.originalCeadPerKg, calculatedCeadPerKg);
                const finalCeadTotal = finalCeadPerKg * modalPrices.qty;

                // Update displays
                document.getElementById('modal-customer-per-kg').textContent = newCustomerPerKg.toFixed(2);
                document.getElementById('modal-cead-total').textContent = finalCeadTotal.toFixed(2);
                document.getElementById('modal-cead-per-kg').textContent = finalCeadPerKg.toFixed(2);

                // Store for submission
                modalPrices.customerTotal = newCustomerTotal;
                modalPrices.ceadTotal = finalCeadTotal;
            });

            els.modal.classList.add("show");
        });

        els.modalCancel.addEventListener("click", () => {
            els.modal.classList.remove("show");
        });

        els.modalConfirm.addEventListener("click", async () => {
            els.modal.classList.remove("show");
            els.msg.style.display = "none";
            els.submit.disabled = true;
            els.submit.textContent = "Submitting...";

            const qty = Number(els.qty.value);

            // Use the (potentially edited) prices from the modal
            const customerPerKg = modalPrices.customerTotal / modalPrices.qty;
            const ceadPerKg = modalPrices.ceadTotal / modalPrices.qty;

            const orderData = {
                customer_id: CONFIG.customerId,
                ordered_by: els.orderedSelect.value === "Other"
                    ? document.getElementById("ordered_by_other").value
                    : els.orderedSelect.value,
                customer: document.getElementById("customer_name").value,
                quantity_kg: qty,
                comment: document.getElementById("order_comment").value || "",
                planned_shipping_date: els.date.value,
                status: 'reserved',
                customer_unit_price: Math.round(customerPerKg * 100) / 100,
                cead_unit_price: Math.round(ceadPerKg * 100) / 100
            };

            try {
                const { data, error } = await db
                    .from('orders')
                    .insert([orderData])
                    .select();

                if (error) throw error;

                // Add the returned order ID to orderData for the email
                if (data && data[0]) {
                    orderData.id = data[0].id;
                }

                // Send notifications (don't wait, don't block on failure)
                sendOrderNotifications(orderData);

                els.msg.className = "message success";
                els.msg.textContent = `Order placed successfully! Delivery scheduled for ${formatDateShort(orderData.planned_shipping_date)}`;
                els.msg.style.display = "block";
                els.form.reset();

                document.getElementById("availability-box").classList.remove("show");
                document.getElementById("date-field").style.display = "none";
                document.getElementById("comment-field").style.display = "none";
                document.getElementById("price-field").style.display = "none";
                document.getElementById("confirm-field").style.display = "none";
                document.getElementById("quantity-hint").style.display = "block";
                calculatedAvailability = null;

                loadDashboard();
            } catch (err) {
                els.msg.className = "message error";
                els.msg.textContent = "Error: " + err.message;
                els.msg.style.display = "block";
            } finally {
                els.submit.disabled = false;
                els.submit.textContent = "Place order";
            }
        });

        els.modal.addEventListener("click", (e) => {
            if (e.target === els.modal) {
                els.modal.classList.remove("show");
            }
        });
    }

    // ============================================
    // Initialize
    // ============================================
    document.getElementById("refresh-btn").onclick = loadDashboard;
    loadDashboard();
    setupForm();
  </script>
</body>
</html>
